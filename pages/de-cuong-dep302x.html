<html>
<body>


<div id="ez-toc-container" class="ez-toc-v2_0_72 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction">
<div class="ez-toc-title-container">
<p class="ez-toc-title" style="cursor:inherit">Mục Lục</p>
<span class="ez-toc-title-toggle"><a href="#" class="ez-toc-pull-right ez-toc-btn ez-toc-btn-xs ez-toc-btn-default ez-toc-toggle" aria-label="Toggle Table of Content"><span class="ez-toc-js-icon-con"><span class=""><span class="eztoc-hide" style="display:none;">Toggle</span><span class="ez-toc-icon-toggle-span"><svg style="fill: #999;color:#999" xmlns="http://www.w3.org/2000/svg" class="list-377408" width="20px" height="20px" viewBox="0 0 24 24" fill="none"><path d="M6 6H4v2h2V6zm14 0H8v2h12V6zM4 11h2v2H4v-2zm16 0H8v2h12v-2zM4 16h2v2H4v-2zm16 0H8v2h12v-2z" fill="currentColor"></path></svg><svg style="fill: #999;color:#999" class="arrow-unsorted-368013" xmlns="http://www.w3.org/2000/svg" width="10px" height="10px" viewBox="0 0 24 24" version="1.2" baseProfile="tiny"><path d="M18.2 9.3l-6.2-6.3-6.2 6.3c-.2.2-.3.4-.3.7s.1.5.3.7c.2.2.4.3.7.3h11c.3 0 .5-.1.7-.3.2-.2.3-.5.3-.7s-.1-.5-.3-.7zM5.8 14.7l6.2 6.3 6.2-6.3c.2-.2.3-.5.3-.7s-.1-.5-.3-.7c-.2-.2-.4-.3-.7-.3h-11c-.3 0-.5.1-.7.3-.2.2-.3.5-.3.7s.1.5.3.7z"/></svg></span></span></span></a></span></div>
<nav><ul class='ez-toc-list ez-toc-list-level-1 ' ><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-1" href="#o1_Khai_niem_ve_ky_thuat_du_lieu_va_he_sinh_thai_ky_thuat_du_lieu" title="o1  Khái niệm về kỹ thuật dữ liệu và hệ sinh thái kỹ thuật dữ liệu">o1  Khái niệm về kỹ thuật dữ liệu và hệ sinh thái kỹ thuật dữ liệu</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-2" href="#o2_Nam_duoc_khai_niem_ve_cac_thanh_phan_trong_he_sinh_thai_du_lieu" title="o2&nbsp; Nắm được khái niệm về các thành phần trong hệ sinh thái dữ liệu">o2&nbsp; Nắm được khái niệm về các thành phần trong hệ sinh thái dữ liệu</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-3" href="#o3_Biet_duoc_cac_cong_cu_ho_tro_trong_ky_thuat_du_lieu" title="o3&nbsp; Biết được các công cụ hỗ trợ trong kỹ thuật dữ liệu">o3&nbsp; Biết được các công cụ hỗ trợ trong kỹ thuật dữ liệu</a><ul class='ez-toc-list-level-3' ><li class='ez-toc-heading-level-3'><a class="ez-toc-link ez-toc-heading-4" href="#Quy_trinh_Ky_thuat_du_lieu" title="Quy trình Kỹ thuật dữ liệu">Quy trình Kỹ thuật dữ liệu</a></li></ul></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-5" href="#o4_Hieu_ro_cac_co_hoi_ve_nghe_nghiep_cung_nhu_dinh_huong_tuong_lai_trong_linh_vuc_ky_thuat_du_lieu" title="o4&nbsp; Hiểu rõ các cơ hội về nghề nghiệp cũng như định hướng tương lai trong lĩnh vực kỹ thuật dữ liệu.">o4&nbsp; Hiểu rõ các cơ hội về nghề nghiệp cũng như định hướng tương lai trong lĩnh vực kỹ thuật dữ liệu.</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-6" href="#o5_Nam_duoc_cac_khai_niem_ve_Data_Warehouse_cung_nhu_mot_so_moi_truong_du_lieu_khac" title="o5&nbsp; Nắm được các khái niệm về Data Warehouse cũng như một số môi trường dữ liệu khác">o5&nbsp; Nắm được các khái niệm về Data Warehouse cũng như một số môi trường dữ liệu khác</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-7" href="#o6_Lua_chon_duoc_cac_kien_truc_phu_hop_de_xay_dung_moi_truong_Data_Warehouse" title="o6&nbsp; Lựa chọn được các kiến trúc phù hợp để xây dựng môi trường Data Warehouse">o6&nbsp; Lựa chọn được các kiến trúc phù hợp để xây dựng môi trường Data Warehouse</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-8" href="#o7_Hieu_duoc_cac_thanh_phan_trong_Data_Warehouse" title="o7&nbsp; Hiểu được các thành phần trong Data Warehouse">o7&nbsp; Hiểu được các thành phần trong Data Warehouse</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-9" href="#o8_Hieu_duoc_cac_loai_ETL_Inital_Load_ETL_va_Incremental_ETL_va_cach_su_dung_tung_loai" title="o8&nbsp; Hiểu được các loại ETL (Inital Load ETL và Incremental ETL) và cách sử dụng từng loại">o8&nbsp; Hiểu được các loại ETL (Inital Load ETL và Incremental ETL) và cách sử dụng từng loại</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-10" href="#o9_Hieu_duoc_khai_niem_ve_ETL_de_dua_du_lieu_vao_Data_Warehouse" title="o9&nbsp; Hiểu được khái niệm về ETL để đưa dữ liệu vào Data Warehouse">o9&nbsp; Hiểu được khái niệm về ETL để đưa dữ liệu vào Data Warehouse</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-11" href="#o10_Xay_dung_duoc_mot_ETL_de_dua_du_lieu_vao_Data_Warehouse" title="o10 Xây dựng được một ETL để đưa dữ liệu vào Data Warehouse">o10 Xây dựng được một ETL để đưa dữ liệu vào Data Warehouse</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-12" href="#o11_Su_dung_SSIS_de_xay_dung_ETL" title="o11 Sử dụng SSIS để xây dựng ETL">o11 Sử dụng SSIS để xây dựng ETL</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-13" href="#o12_Hieu_duoc_tam_quan_trong_cua_viec_bien_doi_du_lieu_va_cac_phep_bien_doi_du_lieu_thuong_dung" title="o12 Hiểu được tầm quan trọng của việc biến đổi dữ liệu và các phép biến đổi dữ liệu thường dùng">o12 Hiểu được tầm quan trọng của việc biến đổi dữ liệu và các phép biến đổi dữ liệu thường dùng</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-14" href="#o13_Hieu_duoc_khai_niem_ve_Facts_Fact_Tables_Dimensions_va_Dimension_Tables" title="o13 Hiểu đươc khái niệm về Facts, Fact Tables, Dimensions, và Dimension Tables">o13 Hiểu đươc khái niệm về Facts, Fact Tables, Dimensions, và Dimension Tables</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-15" href="#o14_Hieu_ve_su_khac_nhau_ve_kien_truc_cung_nhu_uu_diem_giua_Star_Schemas_va_Snowflake_Schemas" title="o14 Hiểu về sự khác nhau về kiến trúc cũng như ưu điểm giữa Star Schemas và Snowflake Schemas">o14 Hiểu về sự khác nhau về kiến trúc cũng như ưu điểm giữa Star Schemas và Snowflake Schemas</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-16" href="#o15_Nam_duoc_khai_niem_ve_cac_loai_khoa_trong_Data_Warehouse_Primary_Key_Foreign_Key_Nature_Key_va_Surrogate_Key" title="o15 Nắm được khái niệm về các loại khóa trong Data Warehouse (Primary Key, Foreign Key, Nature Key và Surrogate Key)">o15 Nắm được khái niệm về các loại khóa trong Data Warehouse (Primary Key, Foreign Key, Nature Key và Surrogate Key)</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-17" href="#o16_Co_the_thiet_ke_duoc_Fact_Table_va_Dimension_Table_phu_hop_voi_du_lieu" title="o16 Có thể thiết kế được Fact Table và Dimension Table phù hợp với dữ liệu">o16 Có thể thiết kế được Fact Table và Dimension Table phù hợp với dữ liệu</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-18" href="#o17_Biet_cach_su_dung_Slowly_Changing_Dimensions_SCD_de_quan_ly_cac_du_lieu_lich_su" title="o17 Biết cách sử dụng Slowly Changing Dimensions (SCD) để quản lý các dữ liệu lịch sử">o17 Biết cách sử dụng Slowly Changing Dimensions (SCD) để quản lý các dữ liệu lịch sử</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-19" href="#o18_Nam_duoc_uu_nhuoc_diem_cua_moi_truong_Cloud_so_voi_On_Premise_luu_tru_tai_cho" title="o18 Nắm được ưu, nhược điểm của môi trường Cloud so với On Premise (lưu trữ tại chỗ)">o18 Nắm được ưu, nhược điểm của môi trường Cloud so với On Premise (lưu trữ tại chỗ)</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-20" href="#o19_Nam_duoc_cach_xay_dung_ETL_cho_Fact_Table_va_Dimension_Table" title="o19 Nắm được cách xây dựng ETL cho Fact Table và Dimension Table">o19 Nắm được cách xây dựng ETL cho Fact Table và Dimension Table</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-21" href="#o20_Hieu_duoc_cac_khai_niem_ve_MongoDB_va_NoSQL" title="o20 Hiểu được các khái niệm về MongoDB và NoSQL">o20 Hiểu được các khái niệm về MongoDB và NoSQL</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-22" href="#o21_Biet_cach_thuc_hien_cac_thao_tac_Them_%E2%80%93_Doc_%E2%80%93_Sua_%E2%80%93_Xoa_tren_MongoDB" title="o21 Biết cách thực hiện các thao tác Thêm &#8211; Đọc &#8211; Sửa &#8211; Xóa trên MongoDB">o21 Biết cách thực hiện các thao tác Thêm &#8211; Đọc &#8211; Sửa &#8211; Xóa trên MongoDB</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-23" href="#o22_Biet_cach_su_dung_cac_toan_tu_de_thuc_hien_cac_thao_tac_CRUD_phuc_tap_hon" title="o22 Biết cách sử dụng các toán tử để thực hiện các thao tác CRUD phức tạp hơn.">o22 Biết cách sử dụng các toán tử để thực hiện các thao tác CRUD phức tạp hơn.</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-24" href="#o23_Biet_cach_su_dung_Aggregation_Framework_de_thuc_hien_cac_thao_tac_xu_ly_du_lieu_phuc_tap" title="o23 Biết cách sử dụng Aggregation Framework để thực hiện các thao tác xử lý dữ liệu phức tạp">o23 Biết cách sử dụng Aggregation Framework để thực hiện các thao tác xử lý dữ liệu phức tạp</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-25" href="#o24_Biet_cach_su_dung_Index_va_Transaction_trong_MongoDB" title="o24 Biết cách sử dụng Index và Transaction trong MongoDB">o24 Biết cách sử dụng Index và Transaction trong MongoDB</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-26" href="#o25_Hieu_ve_cac_co_che_bao_mat_va_tang_hieu_suat_trong_MongoDB" title="o25 Hiểu về các cơ chế bảo mật và tăng hiệu suất trong MongoDB">o25 Hiểu về các cơ chế bảo mật và tăng hiệu suất trong MongoDB</a><ul class='ez-toc-list-level-3' ><li class='ez-toc-heading-level-3'><a class="ez-toc-link ez-toc-heading-27" href="#Bao_mat" title="Bảo mật">Bảo mật</a></li><li class='ez-toc-page-1 ez-toc-heading-level-3'><a class="ez-toc-link ez-toc-heading-28" href="#Hieu_suat" title="Hiệu suất">Hiệu suất</a></li></ul></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-29" href="#o26_Biet_cach_doc_du_lieu_tu_cac_file" title="o26 Biết cách đọc dữ liệu từ các file.">o26 Biết cách đọc dữ liệu từ các file.</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-30" href="#o27_Biet_cach_xu_ly_du_lieu_dang_JSON" title="o27 Biết cách xử lý dữ liệu dạng JSON">o27 Biết cách xử lý dữ liệu dạng JSON</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-31" href="#o28_Biet_cach_su_dung_Regex_de_trich_xuat_du_lieu_tu_chuoi" title="o28 Biết cách sử dụng Regex để trích xuất dữ liệu từ chuỗi.">o28 Biết cách sử dụng Regex để trích xuất dữ liệu từ chuỗi.</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-32" href="#o29_Biet_cach_su_dung_Scrapy_de_thu_thap_du_lieu_tu_cac_web_tinh" title="o29 Biết cách sử dụng Scrapy để thu thập dữ liệu từ các web tĩnh">o29 Biết cách sử dụng Scrapy để thu thập dữ liệu từ các web tĩnh</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-33" href="#o30_Hieu_ro_ve_CSS_Selector_va_xPath_de_lay_du_lieu" title="o30 Hiểu rõ về CSS Selector và xPath để lấy dữ liệu">o30 Hiểu rõ về CSS Selector và xPath để lấy dữ liệu</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-34" href="#o31_Biet_cach_su_dung_Scrapy_va_Splash_de_thu_thap_du_lieu_tu_cac_web_dong" title="o31 Biết cách sử dụng Scrapy và Splash để thu thập dữ liệu từ các web động">o31 Biết cách sử dụng Scrapy và Splash để thu thập dữ liệu từ các web động</a></li><li class='ez-toc-page-1 ez-toc-heading-level-2'><a class="ez-toc-link ez-toc-heading-35" href="#o32_Nam_duoc_cac_Scraping_APIs" title="o32 Nắm được các Scraping APIs">o32 Nắm được các Scraping APIs</a></li></ul></nav></div>
<h2 class="wp-block-heading"><span class="ez-toc-section" id="o1_Khai_niem_ve_ky_thuat_du_lieu_va_he_sinh_thai_ky_thuat_du_lieu"></span>o1  Khái niệm về kỹ thuật dữ liệu và hệ sinh thái kỹ thuật dữ liệu<span class="ez-toc-section-end"></span></h2>



<p><strong>Hệ sinh thái </strong>dữ liệu bao gồm một mạng lưới các thành phần được kết nối với nhau và liên tục phát triển bao gồm:</p>



<ul class="wp-block-list">
<li><strong>Dữ liệu:</strong> Có sẵn ở nhiều định dạng, cấu trúc và nguồn <strong>khác nhau</strong>.</li>



<li>Môi trường <strong>Dữ liệu Doanh nghiệp</strong>: Trong đó dữ liệu thô <strong>được tổ chức</strong>, sắp xếp, làm sạch và tối ưu hóa để người dùng cuối sử dụng.</li>



<li><strong>Người dùng cuối</strong>: Các bên liên quan kinh doanh, nhà phân tích và lập trình viên, những người <strong>sử dụng dữ liệu</strong> cho các mục đích khác nhau.</li>
</ul>



<p>Trong một hệ sinh thái dữ liệu sẽ có rất nhiều vai trò với từng nhiệm vụ khác nhau:</p>



<figure class="wp-block-table"><table><tbody><tr><td><strong>Vai trò</strong></td><td><strong>Công việc</strong></td><td><strong>Các kỹ năng cần có</strong></td></tr><tr><td><strong>Data Engineer (Kỹ sư dữ liệu)</strong></td><td><strong>Xây dựng</strong>, bảo trì các kiến trúc dữ liệu và chuyển hóa dữ liệu để phù hợp cho việc phân tích nghiệp vụ.</td><td>&#8211; Kiến thức tốt về <strong>lập trình</strong>.<br>&#8211; Biết rõ về các <strong>cơ sở dữ liệu</strong> quan hệ và phi quan hệ.</td></tr><tr><td><strong>Data Analyst</strong></td><td>&#8211; Dựa vào các dữ liệu <strong>đã được xử lý</strong> để thu thập <strong>thông tin</strong> chi tiết.<br>&#8211; Xác định các mối tương quan, tìm các <strong>Pattern</strong> và áp dụng các phương pháp thống kê để <strong>phân tích</strong> và khai thác dữ liệu.<br>&#8211; <strong>Trực quan</strong> hóa dữ liệu.</td><td>&#8211; Kỹ năng <strong>lập trình</strong>.<br>&#8211; Có kiến thức tốt về việc sử dụng <strong>bảng tính</strong>, viết <strong>truy vấn</strong>, sử dụng công cụ xác xuất để tạo dashboard và các <strong>biểu đồ</strong>.<br>&#8211; Có khả năng <strong>truyền đạt</strong> tốt.</td></tr><tr><td><strong>Data Scientist</strong></td><td>Xây dựng các <strong>mô hình</strong> chuẩn đoán dựa vào các dữ liệu có sẵn bằng <strong>Machine Learning</strong> hoặc Deep Learning.</td><td>&#8211; Có kiến thức về <strong>Toán</strong> và Xác Xuất.<br>&#8211; Có kiến thức về lập trình, sử dụng Database và xây dựng các mô hình dữ liệu.<br>&#8211; Các kiến thức <strong>nghiệp vụ.</strong></td></tr><tr><td><strong>Bussiness Analyst và BI Analyst</strong></td><td>Làm việc với Data Analyst và Data Scientist để có cái nhìn tổng quan về mặt<strong> nghiệp vụ</strong>. Từ đó xác định được các công việc cần phải triển khai tiếp theo để phát triển <strong>doanh nghiệp</strong>.</td><td>&#8211; Các kiến thức <strong>nghiệp vụ</strong>.</td></tr></tbody></table></figure>



<p><strong>Data Engineer (Kỹ sư dữ liệu)</strong></p>



<p><strong>Nhiệm vụ</strong> của các Kỹ sư dữ liệu:</p>



<ul class="wp-block-list">
<li><strong>Xây dựng</strong>, bảo trì các <strong>kiến trúc</strong> dữ liệu</li>



<li><strong>Chuyển hóa</strong> dữ liệu để phù hợp cho việc phân tích <strong>nghiệp vụ</strong>.</li>



<li>Mục tiêu là cung cấp <strong>dữ liệu chất lượng</strong> để tìm hiểu thực tế và ra quyết định kinh doanh.</li>
</ul>



<p>Các <strong>công việc</strong> chính của Kỹ sư dữ liệu:</p>



<ul class="wp-block-list">
<li><strong>Thu thập</strong> dữ liệu: Lấy dữ liệu từ nhiều nguồn khác nhau, đồng thời thiết kế các kiến trúc để lưu trữ dự liệu.</li>



<li><strong>Xử lý </strong>dữ liệu: Làm gọn, chuyển hóa và chuẩn bị dữ liệu để có thể sử dụng được. Bao gồm các bước như Trích Xuất &#8211; Chuyển Hóa &#8211; Tải dữ liệu.</li>



<li><strong>Lưu trữ</strong> dữ liệu: Bạn cần lưu trữ lại các dữ liệu đã được xử lý, hệ thống lưu trữ cần đảm bảo về tính khả mở cũng như bảo mật.</li>



<li>Xử lý dữ liệu để người dùng có thể sử dụng: Bạn cần<strong> thiết kế các API</strong>, các dịch vụ hoặc các Dashboard để người dùng có thể dễ dàng <strong>truy cập</strong> vào các dữ liệu cần thiết.</li>
</ul>



<p>Kỹ sư dữ liệu cần có sự kết hợp của các Kỹ năng <strong>chuyên môn</strong> và các <strong>Kỹ năng mềm</strong>.</p>



<ul class="wp-block-list">
<li>Kỹ năng<strong> chuyên môn</strong> bao gồm
<ul class="wp-block-list">
<li>Làm việc với các hệ điều hành và các <strong>cơ sở hạ tầng </strong>khác nhau như máy ảo, mạng và dịch vụ ứng dụng</li>



<li>Làm việc với <strong>cơ sở dữ liệu</strong> và Data Warehouse, Data Pipeline, <strong>công cụ ETL</strong>, Big Data và ngôn ngữ để truy vấn, thao tác và xử lý dữ liệu. </li>
</ul>
</li>



<li>Các kỹ năng <strong>nghiệp vụ </strong>bao gồm
<ul class="wp-block-list">
<li>Khả năng <strong>chuyển đổi </strong>các yêu cầu <strong>nghiệp vụ</strong> thành các đặc điểm <strong>kỹ thuật</strong></li>



<li>Hiểu biết về vòng đời phát triển phần mềm và các lĩnh vực chất lượng dữ liệu, quyền riêng tư, bảo mật và quản trị. </li>
</ul>
</li>



<li>Kỹ năng <strong>mềm</strong> bao gồm các kỹ năng <strong>giao tiếp</strong> giữa các cá nhân, khả năng làm việc hợp tác, làm việc <strong>nhóm</strong> và giao tiếp hiệu quả. </li>
</ul>



<p><strong>Hệ sinh thái</strong> Kỹ thuật Dữ liệu</p>



<p><strong>Hệ sinh thái</strong> của Kỹ thuật dữ liệu bao gồm <strong>cơ sở hạ tầng</strong>, công cụ, khuôn khổ và quy trình để trích xuất dữ liệu, lưu trữ và quản lý quy trình dữ liệu và Data Warehouse, quản lý quy trình công việc, phát triển ứng dụng và quản lý các công cụ BI báo cáo.</p>



<p><strong>Các dữ liệu có thể được chia ra thành ba loại như sau:</strong></p>



<ul class="wp-block-list">
<li>Dữ liệu <strong>có cấu trúc</strong>: Dữ liệu có định dạng có thể lưu xuống cơ sở dữ liệu.</li>



<li>Dữ liệu <strong>bán cấu trúc</strong>: Dữ liệu có một phần là cấu trúc, một phần là tự do.</li>



<li>Dữ liệu <strong>phi cấu trúc</strong>: Dữ liệu không thể đưa về dạng bảng để lưu trong cơ sở dữ liệu.</li>
</ul>



<p>Dữ liệu có nhiều <strong>định dạng</strong> tệp khác nhau, chẳng hạn như tệp văn bản được phân tách, bảng tính, XML, PDF và JSON. Dữ liệu cũng được<strong> trích xuất </strong>từ nhiều nguồn dữ liệu, từ cơ sở dữ liệu quan hệ và phi quan hệ, đến API, dịch vụ web, luồng dữ liệu, nền tảng xã hội và thiết bị cảm biến.</p>



<p>Trong việc phát triển các Kho dữ liệu, thường có hai loại chính là <strong>OLTP </strong>(On-line <strong>transactional</strong> processing) và <strong>OLAP</strong> (On-line <strong>analytical</strong> processing).</p>



<ul class="wp-block-list">
<li><strong>OLTP</strong> được thiết kế để lưu trữ một khối lượng lớn <strong>dữ liệu hoạt động hàng ngày</strong> như giao dịch ngân hàng trực tuyến, giao dịch ATM và đặt vé máy bay. Mục đích của OLTP chính là bảo đảm tính chính xác và tính toàn vẹn của các giao dịch, hoạt động.</li>



<li><strong>OLAP</strong> được tối ưu hóa để tiến hành <strong>phân tích dữ liệu phức tạp</strong>. OLAP cho phép chúng ta tìm ra xu hướng, điểm mấu chốt thường phục vụ cho các mục đích phân tích.</li>
</ul>



<p>Các chuyên gia dữ liệu cần các ngôn ngữ có thể giúp họ trích xuất, chuẩn bị và phân tích dữ liệu. Ví dụ:</p>



<ul class="wp-block-list">
<li><strong>Ngôn ngữ truy vấn</strong> được thiết kế để truy cập và thao tác dữ liệu trong một cơ sở dữ liệu, ví dụ: SQL,&#8230;</li>



<li><strong>Ngôn ngữ lập trình</strong> được thiết kế để phát triển các ứng dụng và kiểm soát hành vi ứng dụng như Python, Java,&#8230;</li>



<li><strong>Unix/Linux Shell </strong>được thiết kế cho các tác vụ lặp đi lặp lại gây tốn nhiều thời gian.</li>
</ul>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o2_Nam_duoc_khai_niem_ve_cac_thanh_phan_trong_he_sinh_thai_du_lieu"></span>o2&nbsp; Nắm được khái niệm về các thành phần trong hệ sinh thái dữ liệu<span class="ez-toc-section-end"></span></h2>



<p><strong>Data Repositories</strong> là một thuật ngữ chung đề cập đến dữ liệu đã được thu thập, tổ chức và trích xuất để nó có thể được sử dụng cho báo cáo, phân tích và cũng cho mục đích lưu trữ. Có một số loại Data Repositories như sau:</p>



<ul class="wp-block-list">
<li><strong>Database</strong>: Có thể là cơ sở dữ liệu quan hệ hoặc phi quan hệ.</li>



<li><strong>Data Warehouse:</strong> Tổng hợp và chuyển đồi các dữ liệu từ nhiều nguồn khác nhau.</li>



<li><strong>Data Lake</strong>: Tương tự như Data Warehouse, nhưng dữ liệu sẽ không được xử lý mà đưa thẳng vào luôn.</li>



<li><strong>Data Mart</strong>: Là một dạng nhỏ hơn của Data Warehouse, các dữ liệu chỉ tập trung vào một lĩnh vực duy nhất.</li>



<li><strong>Big Data Stores</strong>: Cung cấp cơ sở hạ tầng lưu trữ và tính toán phân tán để mở rộng quy mô và xử lý các tập dữ liệu rất lớn.</li>
</ul>



<p>Database có thể được chia ra làm <strong>2 loại chính</strong> là:</p>



<ul class="wp-block-list">
<li><strong>RDBMS</strong>: Viết tắt của Relational Database Management System (Hệ thống quản lý cơ sở <strong>dữ liệu quan hệ</strong>). Trong RDBMS, dữ liệu được biểu diễn bởi các hàng. Nó chứa các bảng và mỗi bảng có Primary Key riêng, bởi vì các bảng này được tổ chức chặt chẽ nên việc truy cập dữ liệu trở nên dễ dàng hơn trong RDBMS thông qua ngôn ngữ SQL.</li>



<li><strong>NoSQL</strong>: Là một dạng cơ sở dữ liệu sử dụng cho các <strong>dữ liệu phi cấu trúc</strong>, dữ liệu thường có thể được biểu diễn ở dạng <strong>Document</strong>, Key-Value, Graph hoặc là Column. NoSQL mang đến một số ưu điểm về tốc độ truy vấn cũng như tốc độ thực hiện các thao tác CRUD dữ liệu, đồng thời cũng có thể được mở rộng và chạy trên nhiều cụm máy khác nhau. </li>
</ul>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o3_Biet_duoc_cac_cong_cu_ho_tro_trong_ky_thuat_du_lieu"></span>o3&nbsp; Biết được các công cụ hỗ trợ trong kỹ thuật dữ liệu<span class="ez-toc-section-end"></span></h2>



<p><strong>Nền tảng tích hợp dữ liệu </strong>kết hợp các nguồn dữ liệu khác nhau, về mặt vật lý hoặc logic, để cung cấp một cái nhìn thống nhất về dữ liệu cho các mục đích phân tích. Tích hợp dữ liệu (Data Intergration) bao gồm các công việc như sau:</p>



<ul class="wp-block-list">
<li>Truy cập, truy vấn và trích xuất dữ liệu.</li>



<li>Chuyển đổi và hợp nhất dữ liệu vừa được trích xuất.</li>



<li>Quản lý về chất lượng của dữ liệu.</li>



<li>Cung cấp dữ liệu thông qua các cách tích hợp cho mục đích phân tích.</li>
</ul>



<h3 class="wp-block-heading"><span class="ez-toc-section" id="Quy_trinh_Ky_thuat_du_lieu"></span>Quy trình Kỹ thuật dữ liệu<span class="ez-toc-section-end"></span></h3>



<p>Kiến trúc của nền tảng dữ liệu có thể được xem như một tập hợp các tầng hoặc các thành phần chức năng, mỗi lớp thực hiện một tập hợp các nhiệm vụ cụ thể.</p>



<ul class="wp-block-list">
<li>Tầng<strong> thu thập</strong> dữ liệu: chịu trách nhiệm <strong>đưa dữ liệu từ nguồn</strong> dữ liệu vào nền tảng dữ liệu.</li>



<li>Tầng<strong> tích hợp và lưu trữ </strong>dữ liệu: chịu trách nhiệm<strong> lưu trữ và hợp nhất</strong> dữ liệu đã trích xuất.</li>



<li>Tầng <strong>xử lý</strong> dữ liệu: chịu trách nhiệm <strong>xác thực, chuyển đổi </strong>và áp dụng các quy tắc nghiệp vụ cho dữ liệu.</li>



<li>Tầng<strong> phân tích</strong> giao diện người dùng: chịu trách nhiệm cung cấp <strong>dữ liệu đã xử lý</strong> cho người tiêu dùng dữ liệu.</li>



<li>Tầng<strong> Data Pipeline </strong>(đường ống dữ liệu): chịu trách nhiệm <strong>triển khai</strong> và duy trì quy trình.</li>
</ul>



<figure class="wp-block-image"><img decoding="async" src="https://lh7-us.googleusercontent.com/BIl9JdRcMwGw_6ulFLOXkXKL419Hh3XpMs7g_VrVd59FEWAdSX7zHnglVbCMnU_zlDB2vHy6VSS1eI--wkMZqDD_rB7uD6uiJm_Qw1Iq4_lCqaHvy9F9Q4XP7fIUf-k6pCWSDhEFkpM317KVYjYdj34" alt=""/></figure>



<p><strong>Data Store hay Data Repositories</strong> là một thuật ngữ chung đề cập đến dữ liệu <strong>đã được thu thập</strong>, sắp xếp và tách biệt để nó có thể được sử dụng cho báo cáo, phân tích và cũng cho mục đích lưu trữ.</p>



<p>Việc lựa chọn hoặc thiết kế một Data Store ảnh hưởng bởi loại dữ liệu và khối lượng dữ liệu cần được lưu trữ, mục đích sử dụng dữ liệu. Các nhu cầu về quyền riêng tư, bảo mật và quản trị của tổ chức của bạn cũng ảnh hưởng đến sự lựa chọn này.</p>



<p>Chúng ta sẽ có từng cách riêng biệt để có thể <strong>thu thập</strong> được dữ liệu từ các Data Source khác nhau:</p>



<ul class="wp-block-list">
<li><strong>SQL Query: </strong>bạn có thể sử dụng SQL để truy vấn và lấy dữ liệu <strong>từ các Database</strong>, đồng thời SQL cũng hỗ trợ các theo tác như Group, Count,&#8230; Với các Database thuộc dạng NoSQL thì cũng sẽ có các công cụ truy vấn tương ứng như GraphQL,&#8230;</li>



<li><strong>API:</strong> API thường được sử dụng để thu thập dữ liệu từ các data source, khi được thực thi từ các ứng dụng cần dữ liệu, API sẽ truy cập vào Database, <strong>truy vấn</strong> và trả về dữ liệu cần thiết.</li>



<li><strong>Web Scraping:</strong> Là phương pháp thu thập, trích xuất dữ liệu dạng text, ảnh, video,&#8230; <strong>từ các trang Web</strong>.</li>



<li><strong>Data Stream: </strong>Là phương pháp để tổng hợp các dữ liệu liên tục, phù hợp để thu thập các dữ liệu từ <strong>IoT, cảm biến</strong>, hoặc các ứng dụng thời gian thực.</li>



<li><strong>Data Exchanges</strong>: Cho phép<strong> trao đổi </strong>dữ liệu giữa bên cung cấp và bên cần sử dụng dữ liệu.</li>
</ul>



<p><strong>Làm gọn dữ liệu</strong> liên quan đến loạt các hoạt động <strong>biến đổi và làm sạch</strong> được thực hiện trên dữ liệu. Chuyển đổi dữ liệu thô bao gồm các nhiệm vụ bạn thực hiện như sau:</p>



<ul class="wp-block-list">
<li><strong>Kết hợp</strong> các dữ liệu bằng các thao tác<strong> Joins và Unions</strong>. </li>



<li><strong>Chuẩn hóa</strong> dữ liệu, tức là <strong>làm sạch</strong> cơ sở dữ liệu của <strong>dữ liệu thừa</strong>.</li>



<li><strong>Kết hợp dữ liệu</strong> từ nhiều bảng thành một bảng duy nhất để có thể truy vấn nhanh hơn.</li>
</ul>



<p>Sau khi đã nhập dữ liệu thành công thì dữ liệu đó đã có thể được phân tích. Chúng ta cũng có một số thao tác<strong> phân tích dữ liệu</strong> cơ bản như sau:</p>



<ul class="wp-block-list">
<li><strong>Counting</strong>: Đếm số lượng Row, Record trong tập dữ liệu.</li>



<li><strong>Aggregation</strong>: Tổng hợp dữ liệu từ nhiều khía cạnh khác nhau để có một cái nhìn tổng quát hơn.</li>



<li><strong>Extreme Value </strong>Identification: Xác định các cực trị trong dữ liệu, ví dụ như MIN, MAX, &#8230;</li>



<li><strong>Slicing</strong> Data: Tìm các dữ liệu dựa trên một tập các điều kiện.</li>



<li><strong>Sorting</strong> Data: Sắp xếp lại dữ liệu dựa trên các điều kiện.</li>



<li>Filtering <strong>Patterns</strong>: Lọc các dữ liệu cần thiết</li>
</ul>



<p>Trong vòng đời kỹ thuật dữ liệu, hiệu suất của Data Pipelines, các nền tảng, Databases, ứng dụng, công cụ, truy vấn, and lập lịch cần phải được theo dõi liên tục về hiệu suất và tính khả dụng.&nbsp;</p>



<ul class="wp-block-list">
<li><strong>Hiệu suất</strong> của Data Pipelines có thể bị ảnh hưởng nếu khối lượng công việc tăng lên đáng kể hoặc có lỗi ứng dụng hoặc các Task đã lên lịch không hoạt động như mong đợi, một số công cụ trong Data Pipelines gặp sự cố tương thích. </li>



<li>Cơ sở dữ liệu dễ bị ngừng hoạt động, sử dụng quá mức dung lượng, ứng dụng chạy chậm, các truy vấn bị xung đột khi thực thi đồng thời.</li>
</ul>



<p>Vì vậy mà chúng ta cần một <strong>hệ thống giám sát hiệu suất</strong>. Hệ thống giám sát và cảnh báo sẽ thu thập dữ liệu định lượng trong thời gian thực để cung cấp khả năng hiển thị về hiệu suất của Data Pipelines, nền tảng, Databases, ứng dụng, công cụ, truy vấn, lập lịch,&#8230; Và cũng cần có lịch trình bảo trì dựa trên thời gian và điều kiện tạo ra dữ liệu giúp xác định các hệ thống và quy trình chịu trách nhiệm về lỗi và tính khả dụng thấp.</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o4_Hieu_ro_cac_co_hoi_ve_nghe_nghiep_cung_nhu_dinh_huong_tuong_lai_trong_linh_vuc_ky_thuat_du_lieu"></span>o4&nbsp; Hiểu rõ các cơ hội về nghề nghiệp cũng như định hướng tương lai trong lĩnh vực kỹ thuật dữ liệu.<span class="ez-toc-section-end"></span></h2>



<p>Kỹ sư dữ liệu có thể đảm nhiệm rất nhiều vai trò trong, các vai trò này sẽ phụ thuộc vào công ty mà bạn làm việc, tuy nhiên thông thường sẽ được chia thành các mảng như sau:</p>



<figure class="wp-block-image"><img decoding="async" src="https://lh7-us.googleusercontent.com/VWu-Sc06un-t0ag96ZBSPX4nuuNxsk8K_dTmkRRO-6pb-yCRAcVs74bCPNNjNHyYlQZxGChdQpTTujuJqc2xXT2KqFW4j2eN1nHb63XX2VXkXiWEhDm6JCYZ9KNvnImtRk5MKP7bbHUY9I3IPlbqNYk" alt=""/></figure>



<p>Từ đó cũng sẽ có những vai trò trong Kỹ Thuật Dữ Liệu như sau:</p>



<figure class="wp-block-image"><img decoding="async" src="https://lh7-us.googleusercontent.com/fbUTMNovJGJDeGrMrqUBmim5UtDYwsc9ve67BYiZwE7rZgJSDPDAoLGBXVxtoQLhzbVDSorKNens9_MeEvVGlr_JecEAquyB04piHCh936QSwefUfVoZuv-9HcY0Q0s1da75DYkNZZhpjz6pOEFsNwY" alt=""/></figure>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o5_Nam_duoc_cac_khai_niem_ve_Data_Warehouse_cung_nhu_mot_so_moi_truong_du_lieu_khac"></span>o5&nbsp; Nắm được các khái niệm về Data Warehouse cũng như một số môi trường dữ liệu khác<span class="ez-toc-section-end"></span></h2>



<p><strong>Data Warehouse</strong> là một kỹ thuật thu thập và quản lý dữ liệu từ nhiều nguồn khác nhau để cung cấp những thông tin kinh doanh có ý nghĩa.</p>



<p>Các tính chất của Data Warehouse</p>



<ul class="wp-block-list">
<li><strong>Được tích hợp</strong> (Integrated): Dữ liệu trong Data Warehouse sẽ được lấy từ <strong>nhiều nguồn</strong> dữ liệu (Data Source) khác nhau để có được đầy đủ thông tin.</li>



<li><strong>Hướng chủ đề</strong> (Subject oriented): Tổ chức dữ liệu theo chủ đề để thuận tiện cho việc phân tích. Ví dụ với chủ đề phân tích nhân sự thì có thể bao gồm các độ đo về doanh thu của từng người, số ngày nghỉ trong tháng, số dự án tham gia trong tháng,&#8230; theo các chiều phân tích: thời gian, chi nhánh, sản phẩm,… Chỉ<strong> lưu trữ các dữ liệu cần thiết</strong> cho công việc phân tích, không cần những dữ liệu thừa khác.</li>



<li>Có <strong>gán nhãn thời gian</strong> (Time variant): Các dữ liệu sẽ được gán một nhãn thời gian tương ứng để có thể lưu lại được các dữ liệu lịch sử (Historical data). Dữ liệu lịch sử có tầm quan trọng đặc biệt trong phân tích dữ liệu, cùng một độ đo sẽ có nhiều giá trị khác nhau trong lịch sử có thể dùng để <strong>so sánh</strong> với nhau để biết được<strong> sự thay đổi</strong> là tốt hay xấu. </li>



<li><strong>Bất biến</strong> (Non volatile): Khác với Database thì Data Warehouse chỉ có hai thao tác chính là đọc và ghi dữ liệu. Dữ liệu sẽ <strong>không thể bị thay đổi</strong>, cập nhật do như vậy sẽ không phản ánh đúng với thực tế.</li>
</ul>



<p>Các <strong>lợi ích</strong> khi sử dụng Data Warehouse:</p>



<ul class="wp-block-list">
<li>Hỗ trợ đưa ra quyết định theo <strong>hướng dữ liệu</strong>.</li>



<li>One Stop Shopping: Tất cả dữ liệu (từ nhiều nguồn khác nhau) được tập trung về một chỗ. Giúp cho ta có chỉ cần <strong>tập trung vào việc phân tích</strong> dữ liệu mà không cần phải lo việc thu thập dữ liệu nữa.</li>
</ul>



<p>Một số điểm khác biệt giữa Data Warehouse và Data Lake:</p>



<figure class="wp-block-table"><table><tbody><tr><td><strong>Data Warehouse</strong></td><td><strong>Data Lake</strong></td></tr><tr><td>&#8211; Data Warehouse thường được xây dựng trên một cơ sở dữ liệu quan hệ <strong>(Relational Database)</strong> hoặc hệ cơ sở dữ liệu đa chiều <strong>(Multidimensional Database).</strong><br>&#8211; Data warehouse biến đổi và phân loại dữ liệu từ các nguồn khác nhau của doanh nghiệp. Dữ liệu này sẽ sẵn sàng để phục vụ cho các mục đích khác, đặc biệt là báo cáo và phân tích.<br>&#8211; Gồm các dữ liệu có <strong>cấu trúc cụ thể</strong>.</td><td>&#8211; Data Lake thường được xây dựng trên một môi trường Big Data.<br>&#8211; Data Lake lưu trữ dữ liệu <strong>chưa qua phân tích </strong>và giữ trong trạng thái thô. Những dữ liệu này cần được xử lý thêm khi có nhu cầu sử dụng.<br>&#8211; Có thể chứa t<strong>ất cả các loại dữ liệu</strong>. </td></tr></tbody></table></figure>



<p>Một khái niệm khác hay bị nhầm với Data Warehouse là <strong>Data Virtualization</strong>. Một số điểm khác biệt của Data Virtualization như sau:</p>



<ul class="wp-block-list">
<li>Là một cơ sở dữ liệu quan hệ <strong>Read only</strong> (các dữ liệu chỉ đọc).</li>



<li>Trong quá trình phân tích, thống kê thì sẽ truy cập trực tiếp vào Database thay vì phải sao chép dữ liệu về một chỗ khác.</li>
</ul>



<p>Từ đó, chúng ta có thể thấy được Data Virtualization nên được sử dụng trong các trường hợp sau:</p>



<ul class="wp-block-list">
<li>Không yêu cầu các phép biến đổi dữ liệu quá nặng.</li>



<li>Số lượng nguồn dữ liệu ít.</li>



<li>Thời gian thực hiện truy vấn không quá quan trọng.</li>
</ul>



<p><strong>Quy trình</strong> hoạt động của một môi trường Data Warehouse:</p>



<ul class="wp-block-list">
<li>Dữ liệu từ nhiều nguồn (data source) qua quá trình <strong>ETL</strong> &#8211; Extract (Trích xuất), Load (Tải lên), and Transform (Chuyển đổi) sẽ được đưa vào Data Warehouse.</li>



<li>Đôi khi, các dữ liệu sẽ được tiếp tục chuyển đến cho các môi trường nhỏ hơn như Data Mart</li>
</ul>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o6_Lua_chon_duoc_cac_kien_truc_phu_hop_de_xay_dung_moi_truong_Data_Warehouse"></span>o6&nbsp; Lựa chọn được các kiến trúc phù hợp để xây dựng môi trường Data Warehouse<span class="ez-toc-section-end"></span></h2>



<p><strong>Centralized Data Warehouse:</strong> Là một môi trường chỉ gồm một Data <strong>Warehouse duy nhất</strong>, tất cả các dữ liệu đều được lưu ở đây. Kiến trúc này mang đến một số ưu điểm sau:</p>



<ul class="wp-block-list">
<li><strong>One Stop Shopping</strong> (một điểm dừng): Tất cả dữ liệu (từ nhiều nguồn khác nhau) được tập chung về một chỗ giúp việc phân tích dễ dàng hơn.</li>



<li>Dễ dàng vẽ các <strong>sơ đồ thiết kế</strong>.</li>
</ul>



<p>Như bài trước đã giới thiệu, dữ liệu sẽ không cần dừng lại ở Data Warehouse mà có thể chuyển xuống các môi trường nhỏ hơn như Data Mart. Data mart là một tập hợp nhỏ của Data Warehouse, thường chỉ tập chung vào 1 lĩnh vực duy nhất, ví dụ như Data Mart về sale, về khách hàng,…</p>



<p>⇒ <strong>Data Mart sẽ nhỏ và linh hoạt hơn</strong>. Khi phân tích về một lĩnh vực nhỏ thì sẽ chỉ cần dùng dữ liệu từ Data Mart tương ứng chứ không cần tìm trong Data Warehouse.</p>



<p>Có 2 loại Data Mart:</p>



<figure class="wp-block-table"><table><tbody><tr><td><strong>Dependent Data Mart (phụ thuộc)</strong></td><td><strong>Independent Data Mart (độc lập)</strong></td></tr><tr><td>&#8211; Dữ liệu được <strong>lấy từ Data Warehouse.</strong><br>&#8211; Các dữ liệu sẽ đồng nhất với nhau.</td><td>&#8211; Dữ liệu được lấy trực tiếp <strong>từ các data source</strong>.<br>&#8211; Các dữ liệu không nhất thiết phải đồng nhất với nhau.</td></tr></tbody></table></figure>



<p>Như vậy thì Data Warehouse sẽ khá giống với Independent Data Mart, ta có những sự khác biệt như sau:</p>



<figure class="wp-block-table"><table><tbody><tr><td><strong>Data Warehouse</strong></td><td><strong>Independent Data Mart</strong></td></tr><tr><td>&#8211; Dữ liệu được lấy từ<strong> rất nhiều nguồn</strong>.</td><td>&#8211; Dữ liệu được lấy từ <strong>một số nguồn</strong>.</td></tr></tbody></table></figure>



<p>Khác với Centralized, kiến trúc<strong> Component-Based </strong>sẽ gồm <strong>nhiều thành phần (Data Warehouse, Data Mart hoặc Data Lake)</strong> liên kết lại với nhau.</p>



<p>Để lựa chọn được kiến trúc phù hợp nhất, đầu tiên ta cần chọn giữa Centralized và Component-Based</p>



<figure class="wp-block-table"><table><tbody><tr><td></td><td><strong>Centralized</strong></td><td><strong>Component-Based</strong></td></tr><tr><td>Ưu điểm</td><td>&#8211; Là phương án mặc định.<br>&#8211; One Stop Shopping.<br>&#8211; Công nghệ hiện đại.</td><td>&#8211; Hỗ trợ <strong>Mix-and-Match</strong><br>&#8211; Có thể liên kết <strong>các thành phần</strong> với nhau.<br>&#8211; Dễ xử lý các vấn đề liên quan đến lưu trữ dữ liệu.</td></tr><tr><td>Nhược điểm</td><td>&#8211; Các tổ chức cần liên kết chặt chẽ với nhau,<br>&#8211; <strong>Khả năng quản lý</strong> dữ liệu phải tốt.<br>&#8211; Có thể xảy ra ripple effect. Khi một dữ liệu thay đổi có thể ảnh hưởng đến toàn bộ dữ liệu.</td><td>&#8211; Các dữ liệu thường <strong>không nhất quán </strong>với nhau.<br>&#8211; Khó để tích hợp chéo.</td></tr></tbody></table></figure>



<p>Ngoại trừ cơ sở dữ liệu quan hệ (RDBMS), ta còn có thể sử dụng <strong>cơ sở dữ liệu đa chiều (MDBMS)</strong>. MDBMS thường sẽ phù hợp với các Data Warehouse có quy mô nhỏ.</p>



<figure class="wp-block-table"><table><tbody><tr><td><strong>Ưu điểm</strong></td><td><strong>Nhược điểm</strong></td></tr><tr><td>&#8211; Thời gian truy xuất dữ liệu nhanh.<br>&#8211; Dung lượng lưu trữ không quá lớn.</td><td>&#8211; Cấu trúc ít linh hoạt hơn RDBMS.<br>&#8211; Có nhiều sự biến thể hơn RDBMS.</td></tr></tbody></table></figure>



<p>Ngoài Data Warehouse, ta còn có thể sử dụng <strong>ODS (Operational Data Store)</strong>. ODS giống như Data warehouse nhưng khi dữ liệu được cập nhật sẽ ghi đè lên dữ liệu => ODS sẽ không có các dữ liệu lịch sử (Historical Data).</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o7_Hieu_duoc_cac_thanh_phan_trong_Data_Warehouse"></span>o7&nbsp; Hiểu được các thành phần trong Data Warehouse<span class="ez-toc-section-end"></span></h2>



<p><strong>Staging Layer</strong> (tầng trung gian): Là <strong>khu vực trung gian </strong>thực hiện việc xử lý thông tin cũng như lưu trữ trước khi đưa vào Data Warehouse.</p>



<p><strong>User Access Layer </strong>(tầng <strong>người dùng truy cập</strong>): Là khu vực mà user có thể truy cập được vào dữ liệu.</p>



<figure class="wp-block-image"><img decoding="async" src="https://lh7-us.googleusercontent.com/B-iQOa1ad7I76HGarWPiouIuZhl1wrQZPJ7dCWJxtkjBODce1LXKBjzeLpng_Sorg-azCXIvhcLEuI0mX-6SYuRrO6eYP4szZIYcaIrQdk_3gfD3mj3JC2HjQIJuXNUcx-cnsEfoglUpP2lUaHs0HQo" alt=""/></figure>



<p>Staging Layer được chia ra làm hai loại:</p>



<figure class="wp-block-table"><table><tbody><tr><td></td><td><strong>Non Persistent (không liên tục)</strong></td><td><strong>Persistent (Liên tục)</strong></td></tr><tr><td>Định nghĩa</td><td>&#8211; Sau khi đưa dữ liệu vào Data Warehouse thì sẽ <strong>xóa dữ liệu cũ ở Staging Layer</strong> đi.</td><td>&#8211; Sau khi đưa dữ liệu vào Data Warehouse thì vẫn <strong>giữ dữ liệu cũ ở Staging Layer</strong>.</td></tr><tr><td>Ưu điểm</td><td>&#8211; <strong>Lưu trữ ít hơn</strong>.<br>&#8211; Dữ liệu được chuyển hẳn sang User Layer.</td><td>&#8211; Khi <strong>User Layer gặp lỗi </strong>và cần dựng lại thì có thể lấy trực tiếp dữ liệu từ Staging Layer.<br>&#8211; Để đảm bảo chất lượng dữ liệu thì chỉ cần so sánh giữa User Layer và Staging Layer.</td></tr><tr><td>Nhược điểm</td><td>&#8211; Khi User Layer gặp lỗi và cần dựng lại thì sẽ phải <strong>lấy lại các dữ liệu từ Data Source</strong>.<br>&#8211; Việc đảm bảo chất lượng dữ liệu cũng cần đến Data Source.</td><td>&#8211; Phải lưu trữ nhiều hơn.<br>&#8211; Có rủi ro bị <strong>truy cập trái phép</strong>.</td></tr></tbody></table></figure>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o8_Hieu_duoc_cac_loai_ETL_Inital_Load_ETL_va_Incremental_ETL_va_cach_su_dung_tung_loai"></span>o8&nbsp; Hiểu được các loại ETL (Inital Load ETL và Incremental ETL) và cách sử dụng từng loại<span class="ez-toc-section-end"></span></h2>



<p><strong>BI (Business Intelligence) </strong>là một quy trình có khả năng tích hợp công nghệ giúp các doanh nghiệp kiểm soát khối lượng dữ liệu khổng lồ đến từ nhiều nguồn khác nhau và khai thác nguồn dữ liệu đó một cách hiệu quả. Đồng thời hệ thống tạo ra những tri thức (knowledge) mới giúp cho các nhà quản lý có thể đưa ra các quyết định hiệu quả hơn trong hoạt động kinh doanh của mình.</p>



<p><strong>Initial Load ETL </strong>(ETL tải ban đầu) là một biến thể của ETL, gồm một số đặc điểm sau:</p>



<ul class="wp-block-list">
<li><strong>Chỉ xảy ra một lần</strong> trước khi Data Warehouse được đưa vào vận hành.</li>



<li>Đưa tất cả các dữ liệu cần thiết cho việc phân tích và BI vào Data Warehouse.</li>



<li>Có thể thực hiện lại nếu Data Warehouse gặp lỗi và cần khởi động lại.</li>
</ul>



<p><strong>Incremental ETL</strong></p>



<p>Incremental ETL (ETL gia tăng) cũng là một biến thể của ETL, mục đích là giữ cho các dữ liệu luôn mới nhất bằng cách <strong>thêm các dữ liệu mới hoặc cập nhật các giữ liệu cũ.</strong> Ngoài ra, Incremental ETL cũng xử lý việc xóa dữ liệu. Lúc này thì dữ liệu sẽ không bị xóa hẳn khỏi Data Warehouse mà chỉ đánh dấu là không còn active nữa.</p>



<p><strong>Bốn thao tác trong Incremental ETL:&nbsp;</strong></p>



<ul class="wp-block-list">
<li><strong>Append</strong>: Chèn thêm dữ liệu vào Data Warehouse.</li>



<li><strong>In-place Update</strong>: Thay đổi một số dữ liệu có sẵn.</li>



<li><strong>Complete replacement</strong>: Thay đổi toàn bộ dữ liệu có sẵn.</li>



<li><strong>Rolling append</strong>: Thường được sử dụng trong việc quản lý dữ liệu theo thời gian. Khi chèn thêm một dữ liệu mới thì sẽ xóa dữ liệu cũ tương ứng đi.</li>
</ul>



<p>Thực tế, Data Warehouse sẽ không lấy dữ liệu từ tất cả các Data Source cùng một thời gian, có Data Source sẽ lấy dữ liệu hàng tháng, hoặc hàng giờ,… Và mỗi Data Source cũng sẽ sử dụng một mô hình chuyển đổi khác nhau.</p>



<p>⇒ <strong>Mix-and-Match</strong> (pha trộn và kết hợp) là phương pháp kết hợp nhiều mô hình chuyển đổi với nhau.</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o9_Hieu_duoc_khai_niem_ve_ETL_de_dua_du_lieu_vao_Data_Warehouse"></span>o9&nbsp; Hiểu được khái niệm về ETL để đưa dữ liệu vào Data Warehouse<span class="ez-toc-section-end"></span></h2>



<p><strong>ETL</strong> viết tắt cho:</p>



<ul class="wp-block-list">
<li><strong>Trích xuất </strong>(Extract): Lấy dữ liệu từ các Data Source theo từng lô, bao gồm tất cả dữ liệu thô (chưa qua xử lý) và chuyển đến Staging Layer.</li>



<li><strong>Chuyển đổi </strong>(Transform): Biến đổi để dữ liệu từ nhiều nguồn<strong> đồng nhất </strong>với nhau. Quá trình này có thể rất phức tạp.</li>



<li><strong>Tải (Load):</strong> Chuyển các dữ liệu đã được biến đổi vào User Access Layer.</li>
</ul>



<p>Ngoài ETL thì bạn còn được giới thiệu đến khái niệm về <strong>ELT</strong>. Khác với ETL thì dữ liệu sau khi được trích xuất thì sẽ <strong>lưu xuống Data Lake</strong> / Data Warehouse, sau đó các phép Transform mới được thực hiện ở nơi lưu trữ dữ liệu. Quy trình này mang đến một số ưu điểm như sau:</p>



<ul class="wp-block-list">
<li>Giảm thời gian giữa bước Trích Xuất (Extract) và Phân Phối (Delivery) dữ liệu.</li>



<li>Có thể <strong>sử dụng dữ liệu thô</strong> ngay khi chúng sẵn sàng.</li>



<li>Mang đến sự linh hoạt trong việc phân tích/xử lý dữ liệu do dữ liệu chưa được biến đổi gì hết.</li>



<li>Bạn chỉ cần thực hiện Transform các dữ liệu cần thiết cho một nhu cầu phân tích cụ thể nào đó.</li>
</ul>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o10_Xay_dung_duoc_mot_ETL_de_dua_du_lieu_vao_Data_Warehouse"></span>o10 Xây dựng được một ETL để đưa dữ liệu vào Data Warehouse<span class="ez-toc-section-end"></span></h2>



<p>(Kiểm tra thực hành)</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o11_Su_dung_SSIS_de_xay_dung_ETL"></span>o11 Sử dụng SSIS để xây dựng ETL<span class="ez-toc-section-end"></span></h2>



<p>(Kiểm tra thực hành)</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o12_Hieu_duoc_tam_quan_trong_cua_viec_bien_doi_du_lieu_va_cac_phep_bien_doi_du_lieu_thuong_dung"></span>o12 Hiểu được tầm quan trọng của việc biến đổi dữ liệu và các phép biến đổi dữ liệu thường dùng<span class="ez-toc-section-end"></span></h2>



<p>Bước chuyển đổi giúp các dữ liệu đồng nhất với nhau và phù hợp về mặt nghiệp vụ. Do Data Warehouse lấy dữ liệu từ rất nhiều nguồn khác nhau nên bước chuyển đổi này rất quan trọng.</p>



<p>Các mô hình chuyển đổi:</p>



<ul class="wp-block-list">
<li>Đồng nhất về giá trị.</li>



<li>Đồng nhất về loại và kích thước của dữ liệu.</li>



<li>Loại bỏ các dữ liệu trùng nhau.</li>



<li>Loại bỏ các cột không cần thiết.</li>



<li>Loại bỏ các hàng không cần thiết.</li>



<li>Sửa các lỗi được phát hiện.</li>
</ul>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o13_Hieu_duoc_khai_niem_ve_Facts_Fact_Tables_Dimensions_va_Dimension_Tables"></span>o13 Hiểu đươc khái niệm về Facts, Fact Tables, Dimensions, và Dimension Tables<span class="ez-toc-section-end"></span></h2>



<p>Để bắt đầu xây dựng một Data Warehouse, thì chúng ta cần dựa vào mục đích sử dụng về mặt nghiệp vụ, từ đó chọn ra được data model sẽ sử dụng.</p>



<figure class="wp-block-image"><img decoding="async" src="https://lh7-us.googleusercontent.com/9apdr09Spf_bq9W7H-YO69vr388ZraFWzyboAi4iWHFMccoUB3eko2y4BCZLuNsp7DNAQWeBk-2cNJ7Dn0fNDwHrF5Ug-tjn0K_1rJLQRxJ4cQuGJh7ZXrzrO8B0TbR6YoOkS6OUjdk219-D5OpxzRs" alt=""/></figure>



<p><strong>Facts:</strong> Thường là phép đo (measure), số liệu (metrics) hoặc sự kiện (fact) của quy trình kinh doanh (business process).</p>



<p>Ví dụ: điểm số, thù lao, &#8230; =&gt; Fact Table là một bảng chứa các Fact.</p>



<p><strong>Dimensions</strong>: Cung cấp các thông tin, ngữ cảnh cho Fact.</p>



<p>Ví dụ: tên môn học, tên công ty, &#8230; =&gt; Dimension Table là một bảng chứa các Dimension.</p>



<p><strong>Fact</strong> có thể được chia ra làm <strong>3 loại:</strong></p>



<ul class="wp-block-list">
<li><strong>Additive</strong>: là những Fact có thể được <strong>tổng hợp</strong> thông qua tất cả các Dimension trong Fact Table.</li>



<li><strong>Semi-Additive:</strong> là những Fact <strong>có thể được tóm tắt</strong> cho một số Dimension trong Fact Table chứ không phải là những bảng khác. (ví dụ như tài khoản ngân hàng cuối tháng, có thể tính tổng tại một thời điểm nhất định nhưng không thể tính tổng theo người)</li>



<li><strong>Non-Additive:</strong> là những Fact <strong>không được tóm tắt </strong>cho bất kỳ Dimension hiện tại nào trong Fact Table. (ví dụ như chỉ số đánh giá rating hay mặt hàng giảm giá bao nhiêu %)</li>
</ul>



<p><strong>Fact Table</strong> được chia thành 4 loại chính:</p>



<ul class="wp-block-list">
<li><strong>Transaction</strong>: Dữ liệu chủ yếu là các<strong> Additive Facts</strong> được lưu lại từ các giao dịch.</li>



<li><strong>Periodic Snapshot</strong>: Bảng này lưu trữ Snapshot quy trình kinh doanh trong <strong>một khoảng thời gian </strong>cụ thể.</li>



<li><strong>Accumulating Snapshot</strong>: Đại diện cho <strong>toàn bộ vòng đời</strong> của quy trình kinh doanh từ đầu đến cuối quy trình.</li>



<li><strong>Factless</strong>: Dữ liệu <strong>không bao gồm</strong> một <strong>Fact</strong> nào hết.</li>
</ul>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o14_Hieu_ve_su_khac_nhau_ve_kien_truc_cung_nhu_uu_diem_giua_Star_Schemas_va_Snowflake_Schemas"></span>o14 Hiểu về sự khác nhau về kiến trúc cũng như ưu điểm giữa Star Schemas và Snowflake Schemas<span class="ez-toc-section-end"></span></h2>



<figure class="wp-block-table"><table><tbody><tr><td></td><td><strong>Lược đồ hình sao (Star Schema)</strong></td><td><strong>Lược đồ bông tuyết (Snowflake Schema)</strong></td></tr><tr><td>Định nghĩa</td><td>&#8211; Gồm 1 Fact Table nằm ở trung tâm và được bao quanh bởi những Dimension Table<br>&#8211; Dữ liệu<strong> không được chuẩn hoá</strong>.</td><td>&#8211; Là dạng mở rộng của Star Schema bằng cách chuẩn hóa các Dimension Table.<br>&#8211; Dữ liệu <strong>được chuẩn hoá</strong>.</td></tr><tr><td>Ưu điểm</td><td>&#8211; Fact Table, Dimension Table được mô tả <strong>rõ ràng, dễ hiểu</strong>.<br>&#8211; Khoá của Fact Table được tạo bởi khoá của các Dimension Table. Nghĩa là khoá chính của các Dimension Table chính là khoá của Fact Table.</td><td>&#8211; Số chiều được phân cấp thể hiện dạng chuẩn của Dimension Table.<br>&#8211; Các Dimension Table sử dụng<strong> ít bộ nhớ hơn</strong>.</td></tr><tr><td>Nhược điểm</td><td>Dữ liệu không được chuẩn hóa.</td><td><strong>Cần thực hiện các bước JOIN</strong> bảng để lấy dữ liệu</td></tr></tbody></table></figure>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o15_Nam_duoc_khai_niem_ve_cac_loai_khoa_trong_Data_Warehouse_Primary_Key_Foreign_Key_Nature_Key_va_Surrogate_Key"></span>o15 Nắm được khái niệm về các loại khóa trong Data Warehouse (Primary Key, Foreign Key, Nature Key và Surrogate Key)<span class="ez-toc-section-end"></span></h2>



<p><strong>Khóa chính</strong> (Primary Key) trong Datawarehouse được chia thành 2 loại:</p>



<ul class="wp-block-list">
<li><strong>Surrogate Key</strong>: Là khóa chính dimension table thường có giá trị là kiểu số. Thường được hệ thống DW<strong> sinh ra (duy nhất)</strong> bằng các luồng ETL. Tuy nhiên đây là khóa<strong> không có ý nghĩa trong ngữ cảnh nghiệp vụ</strong>.</li>



<li><strong>Natural Key</strong>: Là loại khoá sử dụng chính một hoặc kết hợp nhiều thuộc tính có sẵn của đối tượng lưu trữ trong CSDL để làm khoá ⇒ có ý nghĩa trong <strong>ngữ cảnh nghiệp vụ</strong>.</li>
</ul>



<p><strong>Primary Key trong Fact Table</strong> sẽ là <strong>tổng hợp của tất cả các Foreign Key</strong> liên kết với các Dimension Table có liên quan (kể cả khi bảng đã có Nature Key).</p>



<p>Foreign Key trong Fact Table sẽ liên kết với các Dimension Table có liên quan.</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o16_Co_the_thiet_ke_duoc_Fact_Table_va_Dimension_Table_phu_hop_voi_du_lieu"></span>o16 Có thể thiết kế được Fact Table và Dimension Table phù hợp với dữ liệu<span class="ez-toc-section-end"></span></h2>



<p>(kiểm tra theo ví dụ đề bài)</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o17_Biet_cach_su_dung_Slowly_Changing_Dimensions_SCD_de_quan_ly_cac_du_lieu_lich_su"></span>o17 Biết cách sử dụng Slowly Changing Dimensions (SCD) để quản lý các dữ liệu lịch sử<span class="ez-toc-section-end"></span></h2>



<p><strong>3 loại SCD</strong>:</p>



<figure class="wp-block-table"><table><tbody><tr><td></td><td><strong>Kỹ thuật</strong></td><td><strong>Tính chất</strong></td></tr><tr><td>Loại 1</td><td>&#8211; In-Place Update<br>&#8211; Đơn giản là <strong>thay đổi giá trị cũ</strong> thành mới</td><td>&#8211; Đây là loại đơn giản nhất nhưng sẽ không giữ được các dữ liệu cũ.</td></tr><tr><td>Loại 2</td><td>&#8211; Khi có thay đổi thì sẽ <strong>chèn thêm 1 hàng </strong>nữa chứa các giá trị update mới ⇒ Giữ cả 2 version cũ và mới.</td><td>&#8211; Phức tạp về mặt kỹ thuật nhưng sẽ giữ lại được các dữ liệu cũ.</td></tr><tr><td>Loại 3</td><td>&#8211; Khi thay đổi giữ liệu thì sẽ có<strong> 2 cột</strong>, một cột chứa giá trị cũ, một cột chứa giá trị mới.</td><td>&#8211; Ưu điểm: Không tăng kích thước của bảng và có thể giữ lại được các dữ liệu cũ.<br>&#8211; Khuyết điểm: Sẽ không dữ được các dữ liệu cũ nếu dữ liệu bị thay đổi nhiều lần.</td></tr></tbody></table></figure>



<p>Nếu như sử dụng <strong>SCD loại 2</strong> thì chúng ta sẽ không biết được đâu là giữ liệu mới nhất. Có một số giải pháp như sau:</p>



<ul class="wp-block-list">
<li><strong>Current_Flag</strong>: Thêm 1 cột current_flag đánh dấu xem đó có phải là giá trị mới nhất không.</li>



<li><strong>Eff_date and Exp_date</strong>: Thêm 2 cột để thể hiện ngày dữ liệu được thêm và ngày dữ liệu bị thay đổi.</li>
</ul>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o18_Nam_duoc_uu_nhuoc_diem_cua_moi_truong_Cloud_so_voi_On_Premise_luu_tru_tai_cho"></span>o18 Nắm được ưu, nhược điểm của môi trường Cloud so với On Premise (lưu trữ tại chỗ)<span class="ez-toc-section-end"></span></h2>



<p>ưu/nhược điểm của Cloud so với việc cài đặt tại chỗ.</p>



<figure class="wp-block-table"><table><tbody><tr><td><strong>Ưu điểm</strong></td><td><strong>Nhược điểm</strong></td></tr><tr><td>&#8211; <strong>Giảm tải bảo trì </strong>và cập nhật hệ thống định kỳ.<br>&#8211; Chi phí đầu tư nền tảng có thể thấp hơn.<br>&#8211; Dễ dàng khắc phục các tai nạn hệ thống.<br>&#8211; Có thể kết hợp với Data Lake và Big Data.</td><td>&#8211; Bảo mật thấp hơn.<br>&#8211; Khó để chuyển dữ liệu từ On-Premises Data Warehouse sang Cloud.<br>&#8211; Khó để chuyển giữa liệu giữa data center và Cloud.</td></tr></tbody></table></figure>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o19_Nam_duoc_cach_xay_dung_ETL_cho_Fact_Table_va_Dimension_Table"></span>o19 Nắm được cách xây dựng ETL cho Fact Table và Dimension Table<span class="ez-toc-section-end"></span></h2>



<p>Quy trình ETL cho Dimension Table:</p>



<p><strong>Bước 1: Chuẩn bị dữ liệu </strong>(data preparation)</p>



<p>Kỹ thuật &#8220;Change Data Capture&#8221;.</p>



<ul class="wp-block-list">
<li>Sử dụng<strong> nhãn thời gian</strong>. Mỗi dữ liệu sẽ có một nhãn thời gian, ta sẽ so sánh và xem dữ liệu nào đã có từ lần ETL trước và loại dữ liệu đó.</li>



<li><strong>So sánh với log </strong>từ database.</li>



<li>Phương án cuối cùng là load toàn bộ dữ liệu và <strong>so sánh với Data Warehouse</strong> để xem dữ liệu nào đã có.</li>
</ul>



<p><strong>Bước 2: Chuyển hóa dữ liệ</strong>u</p>



<p><strong>Bước 3:</strong> Đưa dữ liệu vào <strong>Dimension</strong> Table</p>



<p>Nếu đó là một dữ liệu mới hoàn toàn thì chúng ta chỉ cần thêm dữ liệu đó vào Dimension Table. Nếu dữ liệu đó là cập nhật thì chúng ta sử dụng SCD để lưu lại dữ liệu lịch sử</p>



<p><strong>Bước 4:</strong> Khi đưa môt dữ liệu mới vào<strong> Fact Table,</strong> bạn sẽ dựa vào các dữ liệu trong Dimension Table để biết được đâu là<strong> Surrogate Key của dữ liệu mới</strong> nhất. Tương tự, nếu là các dữ liệu lịch sử được cập nhật thì chúng ta cũng dựa vào Dimension Table để chọn Surrogate Key phù hợp.</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o20_Hieu_duoc_cac_khai_niem_ve_MongoDB_va_NoSQL"></span>o20 Hiểu được các khái niệm về MongoDB và NoSQL<span class="ez-toc-section-end"></span></h2>



<p><strong>MongoDB</strong> là một hệ cơ sở dữ liệu mã nguồn mở thuộc dạng NoSQL. Cấu trúc MongoDB cũng khác với RDBMS:</p>



<ul class="wp-block-list">
<li>MongoDB chứa các <strong>Collection</strong> (có thể coi là một Table trong RDBMS).</li>



<li>Các Collection này sẽ gồm nhiều <strong>Document</strong> (mỗi Document sẽ giống như một record trong RDBMS). Các Document sẽ có cấu trúc dạng <strong>BSON</strong> (khá giống với <strong>JSON</strong>) và mỗi document không bắt buộc phải có một cấu trúc giống nhau như trong RDBMS. Điều này giúp cho tốc độ truy vấn, xử lý dữ liệu trong MongoDB cũng nhanh hơn so với RDBMS.</li>
</ul>



<p>Một số ưu điểm của MongoDB:</p>



<ul class="wp-block-list">
<li>Cấu trúc của một đối tượng rõ ràng.</li>



<li><strong>Không có các Join</strong> phức tạp.</li>



<li><strong>Khả năng mở rộng </strong>cực lớn: việc mở rộng dữ liệu mà không phải lo đến các vấn đề như khóa ngoại, khóa chính, kiểm tra ràng buộc,&#8230; MongoDB cho phép thực hiện replication và sharding nên việc mở rộng cũng thuận lợi hơn. </li>



<li><strong>Ít schema </strong>hơn.</li>
</ul>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o21_Biet_cach_thuc_hien_cac_thao_tac_Them_%E2%80%93_Doc_%E2%80%93_Sua_%E2%80%93_Xoa_tren_MongoDB"></span>o21 Biết cách thực hiện các thao tác Thêm &#8211; Đọc &#8211; Sửa &#8211; Xóa trên MongoDB<span class="ez-toc-section-end"></span></h2>



<p>Thao tác Thêm</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: jscript; title: ; notranslate" title="">
// Thêm một tài liệu vào một collection.
db.products.insertOne({ item: &quot;card&quot;, qty: 15 });

// Thêm nhiều tài liệu vào một collection.
db.products.insertMany(&#x5B;
   { item: &quot;card&quot;, qty: 15 },
   { item: &quot;envelope&quot;, qty: 20 },
   { item: &quot;stamps&quot; , qty: 30 }
]);
</pre></div>


<p>Thao tác Đọc</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: jscript; title: ; notranslate" title="">
// Tìm tất cả các tài liệu phù hợp với truy vấn.
db.bios.find({ _id: 5 })

// Sử dụng projection để lấy các trường cụ thể trong tài liệu.
db.bios.find({ _id: 5 }, { number: 1, count: 1 })

// Tìm tài liệu đầu tiên phù hợp với truy vấn, với một tham số projection tùy chọn.
db.bios.findOne({ _id: 5 })

// Lựa chọn từ một tài liệu lồng nhau.
db.orders.find({ &quot;address.state&quot;: &quot;CA&quot; })
</pre></div>


<p>Thao tác Sửa</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: jscript; title: ; notranslate" title="">
// Cập nhật dữ liệu của tài liệu đầu tiên phù hợp với truy vấn, sử dụng $set để sửa đổi giá trị của các trường hiện có hoặc $unset để loại bỏ một trường.
db.restaurant.updateOne(
   { &quot;name&quot; : &quot;Central Perk Cafe&quot; },
   { $set: { &quot;violations&quot; : 3 } }
);

db.restaurant.updateOne(
   { &quot;name&quot; : &quot;Central Perk Cafe&quot; },
   { $unset: { &quot;address&quot; : &#039;&#039; } }
);

// Cập nhật tất cả các tài liệu phù hợp với truy vấn, sử dụng $set để sửa đổi giá trị của các trường hiện có hoặc $unset để loại bỏ một trường.
db.books.updateMany(
   { type: &#039;Commic&#039; },
   { $set: { &quot;Review&quot; : true } }
);

// Thay thế tài liệu đầu tiên phù hợp với truy vấn.
// Chỉ các trường trong tài liệu thay thế sẽ được bao gồm trong tài liệu mới.
db.restaurant.replaceOne(
   { &quot;name&quot; : &quot;Central Perk Cafe&quot; },
   { &quot;name&quot; : &quot;Central Pork Cafe&quot;, &quot;Borough&quot; : &quot;Manhattan&quot; }
);
</pre></div>


<p>Thao tác Xóa</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: jscript; title: ; notranslate" title="">
// Xóa tài liệu đầu tiên phù hợp với truy vấn.
db.orders.deleteOne({ &quot;_id&quot; : &#039;Order1&#039; });

// Xóa tất cả các tài liệu phù hợp với truy vấn.
db.orders.deleteMany({ &quot;client&quot; : &quot;Crude Traders Inc.&quot; });
</pre></div>


<p>Thao tác Truy vấn</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: jscript; title: ; notranslate" title="">
// $eq: Tìm tài liệu nơi trường &quot;age&quot; bằng 30
db.users.find({ age: { $eq: 30 } })

// $ne: Tìm tài liệu nơi trường &quot;status&quot; không bằng &quot;inactive&quot;
db.users.find({ status: { $ne: &quot;inactive&quot; } })

// $gt: Tìm tài liệu nơi trường &quot;salary&quot; lớn hơn 50000
db.employees.find({ salary: { $gt: 50000 } })

// $gte: Tìm tài liệu nơi trường &quot;rating&quot; lớn hơn hoặc bằng 4
db.products.find({ rating: { $gte: 4 } })

// $lt: Tìm tài liệu nơi trường &quot;price&quot; nhỏ hơn 100
db.products.find({ price: { $lt: 100 } })

// $lte: Tìm tài liệu nơi trường &quot;quantity&quot; nhỏ hơn hoặc bằng 10
db.inventory.find({ quantity: { $lte: 10 } })

// $in: Tìm tài liệu nơi trường &quot;category&quot; là &quot;books&quot; hoặc &quot;electronics&quot;
db.products.find({ category: { $in: &#x5B;&quot;books&quot;, &quot;electronics&quot;] } })

// $nin: Tìm tài liệu nơi trường &quot;status&quot; không phải là &quot;open&quot; hoặc &quot;pending&quot;
db.tickets.find({ status: { $nin: &#x5B;&quot;open&quot;, &quot;pending&quot;] } })

// $or: Tìm tài liệu nơi trường &quot;age&quot; là 30 hoặc 40
db.users.find({ $or: &#x5B;{ age: 30 }, { age: 40 }] })

// $nor: Tìm tài liệu nơi trường &quot;age&quot; không phải là 30 hoặc 40
db.users.find({ $nor: &#x5B;{ age: 30 }, { age: 40 }] })

// $and: Tìm tài liệu nơi trường &quot;status&quot; là &quot;active&quot; và trường &quot;role&quot; là &quot;admin&quot;
db.users.find({ $and: &#x5B;{ status: &quot;active&quot; }, { role: &quot;admin&quot; }] })

// $not: Tìm tài liệu nơi trường &quot;status&quot; không phải là &quot;inactive&quot;
db.users.find({ status: { $not: { $eq: &quot;inactive&quot; } } })

// $exists: Tìm tài liệu nơi trường &quot;email&quot; tồn tại
db.users.find({ email: { $exists: true } })

// $type: Tìm tài liệu nơi trường &quot;age&quot; là kiểu &quot;number&quot;
db.users.find({ age: { $type: &quot;number&quot; } })

// $regex: Tìm tài liệu nơi trường &quot;name&quot; bắt đầu bằng &quot;Joh&quot;
db.users.find({ name: { $regex: /^Joh/ } })

// $expr: Tìm tài liệu nơi giá trị trường &quot;likes&quot; lớn hơn giá trị trường &quot;dislikes&quot;
// Sử dụng $expr khi bạn cần so sánh các trường trong cùng một tài liệu
db.articles.find({ $expr: { $gt: &#x5B;&quot;$likes&quot;, &quot;$dislikes&quot;] } })

// $size: Tìm tất cả các tài liệu mà mảng &quot;hobbies&quot; có đúng 3 phần tử
db.users.find({ hobbies: { $size: 3 } })

// $all: Tìm tất cả các tài liệu mà mảng &quot;tags&quot; chứa các phần tử &quot;electronics&quot; và &quot;smartphone&quot;
db.products.find({ tags: { $all: &#x5B;&quot;electronics&quot;, &quot;smartphone&quot;] } })

// Kết hợp
db.collection(&#039;myCollection&#039;).find({
  $or: &#x5B;
    { age: { $gte: 18, $lte: 30 } }, // tìm tài liệu với tuổi từ 18 đến 30
    { occupation: &#039;student&#039; } // tìm tài liệu với nghề nghiệp là &#039;student&#039;
  ],
  $and: &#x5B;
    { salary: { $gte: 50000 } }, // tìm tài liệu có lương &gt;= 50000
    { location: { $regex: /^New York/ } } // tìm tài liệu với địa điểm bắt đầu bằng &#039;New York&#039;
  ],
  $not: { company: &#039;Microsoft&#039; } // tìm tài liệu không có công ty = &#039;Microsoft&#039;
})

// $: Tìm mục đầu tiên trong mảng &quot;items&quot; có tên là &quot;Widget&quot;
db.orders.find({ &quot;items.name&quot;: &quot;Widget&quot; }, { &quot;items.$&quot;: 1 })

// $elemMatch: Tìm tất cả các đơn hàng có ít nhất một mục có tên là &quot;Widget&quot; và giá lớn hơn 10
db.orders.find({ items: { $elemMatch: { name: &quot;Widget&quot;, price: { $gt: 10 } } } })

// $slice: Tìm tất cả các sản phẩm và trả về chỉ 5 phần tử đầu tiên của mảng &quot;reviews&quot; cho mỗi sản phẩm
db.products.find({}, { reviews: { $slice: 5 } })
</pre></div>


<h2 class="wp-block-heading"><span class="ez-toc-section" id="o22_Biet_cach_su_dung_cac_toan_tu_de_thuc_hien_cac_thao_tac_CRUD_phuc_tap_hon"></span>o22 Biết cách sử dụng các toán tử để thực hiện các thao tác CRUD phức tạp hơn.<span class="ez-toc-section-end"></span></h2>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: jscript; title: ; notranslate" title="">
// $eq: Tìm tài liệu nơi trường &quot;age&quot; bằng 30
db.users.find({ age: { $eq: 30 } })

// $ne: Tìm tài liệu nơi trường &quot;status&quot; không bằng &quot;inactive&quot;
db.users.find({ status: { $ne: &quot;inactive&quot; } })

// $gt: Tìm tài liệu nơi trường &quot;salary&quot; lớn hơn 50000
db.employees.find({ salary: { $gt: 50000 } })

// $gte: Tìm tài liệu nơi trường &quot;rating&quot; lớn hơn hoặc bằng 4
db.products.find({ rating: { $gte: 4 } })

// $lt: Tìm tài liệu nơi trường &quot;price&quot; nhỏ hơn 100
db.products.find({ price: { $lt: 100 } })

// $lte: Tìm tài liệu nơi trường &quot;quantity&quot; nhỏ hơn hoặc bằng 10
db.inventory.find({ quantity: { $lte: 10 } })

// $in: Tìm tài liệu nơi trường &quot;category&quot; là &quot;books&quot; hoặc &quot;electronics&quot;
db.products.find({ category: { $in: &#x5B;&quot;books&quot;, &quot;electronics&quot;] } })

// $nin: Tìm tài liệu nơi trường &quot;status&quot; không phải là &quot;open&quot; hoặc &quot;pending&quot;
db.tickets.find({ status: { $nin: &#x5B;&quot;open&quot;, &quot;pending&quot;] } })

// $or: Tìm tài liệu nơi trường &quot;age&quot; là 30 hoặc 40
db.users.find({ $or: &#x5B;{ age: 30 }, { age: 40 }] })

// $nor: Tìm tài liệu nơi trường &quot;age&quot; không phải là 30 hoặc 40
db.users.find({ $nor: &#x5B;{ age: 30 }, { age: 40 }] })

// $and: Tìm tài liệu nơi trường &quot;status&quot; là &quot;active&quot; và trường &quot;role&quot; là &quot;admin&quot;
db.users.find({ $and: &#x5B;{ status: &quot;active&quot; }, { role: &quot;admin&quot; }] })

// $not: Tìm tài liệu nơi trường &quot;status&quot; không phải là &quot;inactive&quot;
db.users.find({ status: { $not: { $eq: &quot;inactive&quot; } } })

// $exists: Tìm tài liệu nơi trường &quot;email&quot; tồn tại
db.users.find({ email: { $exists: true } })

// $type: Tìm tài liệu nơi trường &quot;age&quot; là kiểu &quot;number&quot;
db.users.find({ age: { $type: &quot;number&quot; } })

// $regex: Tìm tài liệu nơi trường &quot;name&quot; bắt đầu bằng &quot;Joh&quot;
db.users.find({ name: { $regex: /^Joh/ } })

// $expr: Tìm tài liệu nơi giá trị trường &quot;likes&quot; lớn hơn giá trị trường &quot;dislikes&quot;
// Sử dụng $expr khi bạn cần so sánh các trường trong cùng một tài liệu
db.articles.find({ $expr: { $gt: &#x5B;&quot;$likes&quot;, &quot;$dislikes&quot;] } })

// $size: Tìm tất cả các tài liệu mà mảng &quot;hobbies&quot; có đúng 3 phần tử
db.users.find({ hobbies: { $size: 3 } })

// $all: Tìm tất cả các tài liệu mà mảng &quot;tags&quot; chứa các phần tử &quot;electronics&quot; và &quot;smartphone&quot;
db.products.find({ tags: { $all: &#x5B;&quot;electronics&quot;, &quot;smartphone&quot;] } })

// Kết hợp
db.collection(&#039;myCollection&#039;).find({
  $or: &#x5B;
    { age: { $gte: 18, $lte: 30 } }, // tìm tài liệu với tuổi từ 18 đến 30
    { occupation: &#039;student&#039; } // tìm tài liệu với nghề nghiệp là &#039;student&#039;
  ],
  $and: &#x5B;
    { salary: { $gte: 50000 } }, // tìm tài liệu có lương &gt;= 50000
    { location: { $regex: /^New York/ } } // tìm tài liệu với địa điểm bắt đầu bằng &#039;New York&#039;
  ],
  $not: { company: &#039;Microsoft&#039; } // tìm tài liệu không có công ty = &#039;Microsoft&#039;
})

// $: Tìm mục đầu tiên trong mảng &quot;items&quot; có tên là &quot;Widget&quot;
db.orders.find({ &quot;items.name&quot;: &quot;Widget&quot; }, { &quot;items.$&quot;: 1 })

// $elemMatch: Tìm tất cả các đơn hàng có ít nhất một mục có tên là &quot;Widget&quot; và giá lớn hơn 10
db.orders.find({ items: { $elemMatch: { name: &quot;Widget&quot;, price: { $gt: 10 } } } })

// $slice: Tìm tất cả các sản phẩm và trả về chỉ 5 phần tử đầu tiên của mảng &quot;reviews&quot; cho mỗi sản phẩm
db.products.find({}, { reviews: { $slice: 5 } })
</pre></div>


<h2 class="wp-block-heading"><span class="ez-toc-section" id="o23_Biet_cach_su_dung_Aggregation_Framework_de_thuc_hien_cac_thao_tac_xu_ly_du_lieu_phuc_tap"></span>o23 Biết cách sử dụng Aggregation Framework để thực hiện các thao tác xử lý dữ liệu phức tạp<span class="ez-toc-section-end"></span></h2>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: jscript; title: ; notranslate" title="">
db.collection.aggregate(&#x5B;
  // Giai đoạn $match
  {
    $match: {
      age: { $gte: 18 } // tìm các tài liệu có tuổi lớn hơn hoặc bằng 18
    }
  },
  // Giai đoạn $project
  {
    $project: {
      firstName: 1,
      lastName: 1,
      fullName: { $concat: &#x5B;&quot;$firstName&quot;, &quot; &quot;, &quot;$lastName&quot;] }
      // chỉ chọn firstName, lastName và một trường mới fullName nối từ firstName và lastName
    }
  },
  // Giai đoạn $group
  {
    $group: {
      _id: &quot;$gender&quot;, // nhóm theo giới tính
      count: { $sum: 1 } // đếm số lượng tài liệu trong mỗi nhóm
    }
  },
  // Giai đoạn $sort
  {
    $sort: {
      count: -1 // sắp xếp theo count theo thứ tự giảm dần
    }
  },
  // Giai đoạn $limit
  {
    $limit: 10 // chỉ trả về 10 kết quả hàng đầu
  }
]);

// Chuyển đổi
// Bạn cũng có thể sử dụng các toán tử có sẵn khác như: $toDate, $toInt, $toBool,...

db.persons.aggregate(&#x5B;
  {
    $project: {
      _id: 0,
      name: 1,
      email: 1,
      birthdate: {
        $convert: {
          input: &#039;$dob.date&#039;,
          to: &#039;date&#039;
        }
      }
    }
  }
]).pretty();
</pre></div>


<p>Toán tử $bucket được sử dụng để phân loại các tài liệu thành các nhóm, dựa trên biểu thức và ranh giới đã chỉ định. Ví dụ:</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: jscript; title: ; notranslate" title="">
db.persons.aggregate(&#x5B;
  {
    $bucket: {
      groupBy: &#039;$dob.age&#039;,
      boundaries: &#x5B;18, 30, 40, 50, 60, 120],
      output: {
        numPersons: { $sum: 1 },
        averageAge: { $avg: &#039;$dob.age&#039; }
      }
    }
  }
]).pretty();
</pre></div>


<p><br>Trong giai đoạn <strong>$project </strong>của một pipeline aggregation, bạn có thể sử dụng nhiều toán tử khác ngoài các toán tử toán học. Một số ví dụ bao gồm:</p>



<ul class="wp-block-list">
<li>Toán tử so sánh: $eq, $ne, $gt, $gte, $lt, $lte</li>



<li>Toán tử logic: $and, $or, $not, $nor</li>



<li>Toán tử chuỗi: $concat, $substr, $toLower, $toUpper, $trim</li>



<li>Toán tử ngày tháng: $dateToString, $dayOfMonth, $dayOfWeek, $year, $month, $hour, $minute, $second, $millisecond</li>



<li>Toán tử mảng: $arrayElemAt, $concatArrays, $filter, $in, $slice</li>



<li>Toán tử điều kiện: $cond, $ifNull</li>
</ul>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o24_Biet_cach_su_dung_Index_va_Transaction_trong_MongoDB"></span>o24 Biết cách sử dụng Index và Transaction trong MongoDB<span class="ez-toc-section-end"></span></h2>



<p><strong>Index</strong> cũng cho phép bạn thiết lập một số lựa chọn để việc sử dụng Index hiện quả hơn</p>



<ul class="wp-block-list">
<li><strong>Unique</strong>: Tạo một Unique Index để Collection sẽ không chấp nhận việc chèn hoặc cập nhật các Document trong đó giá trị khóa Index khớp với giá trị hiện có trong Index.</li>



<li><strong>PartialFilterExpression</strong>: Tạo Partial Indexes chỉ tham chiếu tới các một số Document thỏa mãn điều kiện</li>



<li><strong>ExpireAfterSeconds</strong>: Chỉ định khoảng thời gian mà MongoDB sẽ giữ cho Document tồn tại</li>
</ul>



<p><strong>Multikey Indexes </strong>là một dạng Index đặc biệt sử dụng cho các <strong>trường dạng mảng</strong>. Multikey Indexes sẽ tạo các khóa cho từng phần tử trong mảng, từ đó giúp cho việc truy vấn phần tử mảng nhanh hơn.</p>



<p><strong>Text Indexes</strong> được sử dụng cho các trường <strong>dạng chuỗi.</strong> Nếu bạn chỉ tạo index đơn thuần cho các trường dạng chuỗi, lúc này Index chỉ phát huy tác dụng khi bạn tìm theo một chuỗi đầy đủ nhưng sẽ không tốt nếu bạn muốn tìm chuỗi theo từ khóa. Lúc này thì bạn nên sử dụng Text Indexes, MongoDB sẽ tự động cắt chuỗi thành từng từ khóa nhỏ, đồng thời cũng lọc đi các từ khóa vô nghĩa (a, an, of, the,&#8230;) và tạo Index cho từng từ khóa. Lúc này khi tìm chuỗi theo từ khóa sẽ nhanh hơn.</p>



<p>Lưu ý là mỗi Collection chỉ có thể có một Text Indexes duy nhất. Do Text Indexes sẽ <strong>tốn rất nhiều bộ nhớ </strong>nên nếu có quá nhiều thì sẽ ảnh hưởng lớn đến hệ thống.</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o25_Hieu_ve_cac_co_che_bao_mat_va_tang_hieu_suat_trong_MongoDB"></span>o25 Hiểu về các cơ chế bảo mật và tăng hiệu suất trong MongoDB<span class="ez-toc-section-end"></span></h2>



<h3 class="wp-block-heading"><span class="ez-toc-section" id="Bao_mat"></span>Bảo mật<span class="ez-toc-section-end"></span></h3>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: jscript; title: ; notranslate" title="">
// Chuyển sang cơ sở dữ liệu admin (BẮT BUỘC)
use admin

// Tạo một người dùng mới
db.createUser(
  {
    user: &quot;myuser&quot;,
    pwd: &quot;mypassword&quot;,
    roles: &#x5B;
      { role: &quot;read&quot;, db: &quot;myproject&quot; }
    ]
  }
);

// Thiết lập một vai trò mới cho người dùng
db.grantRolesToUser(
  &quot;myuser&quot;,
  &#x5B;
    { role: &quot;readWrite&quot;, db: &quot;myproject&quot; }
  ]
);

// Mở rộng vai trò của người dùng
db.grantRolesToUser(
  &quot;myuser&quot;,
  &#x5B;
    { role: &quot;dbAdmin&quot;, db: &quot;myproject&quot; }
  ]
);

// Xác thực người dùng
db.auth(&quot;myuser&quot;, &quot;mypassword&quot;);

// Tạo một người dùng mới với quyền đọc và ghi vào cơ sở dữ liệu &quot;blog&quot;
// và thiết lập cơ sở dữ liệu xác thực là &quot;blog&quot;:
db.createUser({
  user: &quot;myuser&quot;,
  pwd: &quot;mypassword&quot;,
  roles: &#x5B;{ role: &quot;readWrite&quot;, db: &quot;blog&quot; }],
  authenticationDatabase: &quot;blog&quot;
})

// Xác minh rằng người dùng đã được tạo bằng cách chuyển sang cơ sở dữ liệu xác thực
// và chạy lệnh &quot;show users&quot;:
use blog
show users
</pre></div>


<h3 class="wp-block-heading"><span class="ez-toc-section" id="Hieu_suat"></span>Hiệu suất<span class="ez-toc-section-end"></span></h3>



<p><strong>Capped Collection</strong></p>



<p>Capped collections là các Circular Collection có kích cỡ cố định mà theo sau thứ tự chèn để làm tăng cao hiệu suất của các hoạt động create, read và delete. Với Circular, nó nghĩa là khi kích cỡ cố định được cấp phát hết cho Collection, thì nó sẽ bắt đầu<strong> xóa Document cũ nhất</strong> trong Collection đó mà không cần cung cấp bất kỳ lệnh tường minh nào.</p>



<p>Capped Collection giới hạn các hoạt động cập nhật tới Document nếu các cập nhật đó làm tăng kích cỡ của Document. Khi Capped Collection lưu giữ các Document theo trật tự của Disk Storage, nó bảo đảm rằng kích cỡ tài liệu không tăng hơn kích cỡ được cấp phát trên Disk. Capped Collection là tốt nhất để lưu giữ thông tin log, cache data, …</p>



<p><strong>Replica Sets</strong></p>



<p>Replica Sets trong MongoDB là một<strong> nhóm các instance </strong>của MongoDB duy trì cùng một bộ dữ liệu. Các replica set cung cấp tính dự phòng và tính sẵn sàng cao và là cơ sở để triển khai nhập xuất dữ liệu khi cần thiết.</p>



<p><strong>Sharding</strong></p>



<p>Sharding là một tiến trình lưu giữ các bản ghi dữ liệu qua nhiều thiết bị và nó là một phương pháp của MongoDB để đáp ứng yêu cầu về sự gia tăng dữ liệu. Khi kích cỡ của dữ liệu tăng lên, một thiết bị đơn không thể đủ để lưu giữ dữ liệu. Sharding giải quyết vấn đề này với việc<strong> mở rộng phạm vi theo bề ngang (horizontal scaling)</strong>. Với Sharding, bạn bổ sung thêm nhiều thiết bị để hỗ trợ cho việc gia tăng dữ liệu và các yêu cầu của các hoạt động đọc và ghi.</p>



<h2 class="wp-block-heading"><span class="ez-toc-section" id="o26_Biet_cach_doc_du_lieu_tu_cac_file"></span>o26 Biết cách đọc dữ liệu từ các file.<span class="ez-toc-section-end"></span></h2>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: python; title: ; notranslate" title="">
# Ví dụ về đọc từ một tệp
with open(&#039;Example1.txt&#039;, &#039;r&#039;) as file_object:
    file_stuff = file_object.read()
print(file_stuff)

# Đọc các dòng từ một tệp
with open(&#039;Example1.txt&#039;, &#039;r&#039;) as file_object:
    file_stuff = file_object.readlines()
for line in file_stuff:
    print(line)

# Đọc một dòng tại một thời điểm từ một tệp
with open(&#039;Example1.txt&#039;, &#039;r&#039;) as file_object:
    file_stuff = file_object.readline()
    print(file_stuff)
    file_stuff = file_object.readline()
    print(file_stuff)

# Đọc một số lượng ký tự cụ thể từ một tệp
with open(&#039;Example1.txt&#039;, &#039;r&#039;) as file_object:
    file_stuff = file_object.read(4)  # Đọc 4 ký tự đầu tiên
    print(file_stuff)
    file_stuff = file_object.read(16)  # Đọc 16 ký tự tiếp theo
    print(file_stuff)
    file_stuff = file_object.read(5)  # Đọc 5 ký tự tiếp theo
    print(file_stuff)

# Ghi vào một tệp
with open(&#039;Example2.txt&#039;, &#039;w&#039;) as file_object:
    file_object.write(&#039;Hello, world!\n&#039;)  # Ghi chuỗi vào tệp
    file_object.write(&#039;This is a new line.\n&#039;)  # Ghi chuỗi mới vào dòng mới

# Ghi thêm vào một tệp
with open(&#039;Example2.txt&#039;, &#039;a&#039;) as file_object:
    file_object.write(&#039;This is a third line.\n&#039;)  # Ghi thêm chuỗi vào cuối tệp
</pre></div>


<h2 class="wp-block-heading"><span class="ez-toc-section" id="o27_Biet_cach_xu_ly_du_lieu_dang_JSON"></span>o27 Biết cách xử lý dữ liệu dạng JSON<span class="ez-toc-section-end"></span></h2>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: python; title: ; notranslate" title="">
import json

# Link tới tệp JSON trên Google Drive
# https://drive.google.com/file/d/17IbjlB_f1xVAqBd8lLS6BIVGnmmPRTJp/view

# Tạo một từ điển
person = {
    &quot;name&quot;: &quot;John&quot;,
    &quot;age&quot;: 30,
    &quot;city&quot;: &quot;New York&quot;
}

# Chuyển đổi từ điển thành chuỗi JSON
person_json = json.dumps(person)

# In ra chuỗi JSON
print(person_json)

# Chuyển đổi chuỗi JSON thành từ điển
person_dict = json.loads(person_json)

# In ra từ điển
print(person_dict)

# Lưu từ điển vào tệp JSON
with open(&quot;person.json&quot;, &quot;w&quot;) as f:
    json.dump(person_dict, f)

# Đọc từ điển từ tệp JSON
with open(&quot;person.json&quot;, &quot;r&quot;) as f:
    person_from_file = json.load(f)

# In ra từ điển được tải từ tệp
print(person_from_file)

# Truy cập key &#039;name&#039; của từ điển
print(person_from_file&#x5B;&#039;name&#039;])

# Truy cập key &#039;age&#039; của từ điển
print(person_from_file&#x5B;&#039;age&#039;])

# Truy cập key &#039;city&#039; của từ điển
print(person_from_file&#x5B;&#039;city&#039;])
</pre></div>


<h2 class="wp-block-heading"><span class="ez-toc-section" id="o28_Biet_cach_su_dung_Regex_de_trich_xuat_du_lieu_tu_chuoi"></span>o28 Biết cách sử dụng Regex để trích xuất dữ liệu từ chuỗi.<span class="ez-toc-section-end"></span></h2>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: python; title: ; notranslate" title="">
import re

# Tìm kiếm một mẫu trong một chuỗi
text = &quot;The quick brown fox jumps over the lazy dog&quot;
pattern = &quot;brown&quot;
match = re.search(pattern, text)
if match:
    print(f&quot;Found &#039;{pattern}&#039; in &#039;{text}&#039; at position {match.start()}&quot;)
else:
    print(f&quot;&#039;{pattern}&#039; not found in &#039;{text}&#039;&quot;)

# Tìm tất cả các xuất hiện của một mẫu trong một chuỗi
text = &quot;The quick brown fox jumps over the lazy dog&quot;
pattern = &quot;the&quot;
matches = re.findall(pattern, text, re.IGNORECASE)
if matches:
    print(f&quot;Found {len(matches)} occurrences of &#039;{pattern}&#039; in &#039;{text}&#039;&quot;)
else:
    print(f&quot;&#039;{pattern}&#039; not found in &#039;{text}&#039;&quot;)

# Thay thế tất cả các xuất hiện của một mẫu trong một chuỗi
text = &quot;The quick brown fox jumps over the lazy dog&quot;
pattern = &quot;the&quot;
replacement = &quot;THE&quot;
new_text = re.sub(pattern, replacement, text, flags=re.IGNORECASE)
print(f&quot;Original text: &#039;{text}&#039;&quot;)
print(f&quot;New text: &#039;{new_text}&#039;&quot;)
</pre></div>


<h2 class="wp-block-heading"><span class="ez-toc-section" id="o29_Biet_cach_su_dung_Scrapy_de_thu_thap_du_lieu_tu_cac_web_tinh"></span>o29 Biết cách sử dụng Scrapy để thu thập dữ liệu từ các web tĩnh<span class="ez-toc-section-end"></span></h2>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: python; title: ; notranslate" title="">
# Tạo một dự án Scrapy mới có tên là &quot;worldometers&quot;.
scrapy startproject worldometers

# Tạo một spider mới có tên là &quot;countries&quot; để trích xuất dữ liệu từ trang web worldometers.info.
scrapy genspider countries www.worldometers.info/world-population/population-by-country

# Chạy spider &quot;countries&quot; trong dự án để trích xuất dữ liệu.
scrapy crawl countries

# Chạy spider &quot;countries&quot; và lưu kết quả vào tệp population_dataset.csv.
scrapy crawl countries -o population_dataset.csv

# Bắt đầu Scrapy Shell cho URL được cung cấp để thử nghiệm và phát triển spiders.
scrapy shell &#x5B;url]
</pre></div>


<h2 class="wp-block-heading"><span class="ez-toc-section" id="o30_Hieu_ro_ve_CSS_Selector_va_xPath_de_lay_du_lieu"></span>o30 Hiểu rõ về CSS Selector và xPath để lấy dữ liệu<span class="ez-toc-section-end"></span></h2>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: bash; title: ; notranslate" title="">
# Chọn phần tử div với id &#039;main&#039;
//div&#x5B;@id=&#039;main&#039;]

# Chọn phần tử h1 trong phần tử div có id &#039;main&#039;
//div&#x5B;@id=&#039;main&#039;]/h1

# Chọn tất cả các phần tử a trong các phần tử li nằm dưới div có id &#039;main&#039;
//div&#x5B;@id=&#039;main&#039;]//li/a

# Chọn phần tử div với id &#039;main&#039;
div#main

# Chọn phần tử h1 trong phần tử div có id &#039;main&#039;
div#main h1

# Chọn tất cả các phần tử a trong các phần tử li nằm dưới div có id &#039;main&#039;
div#main li a

# Chọn phần tử div có class &#039;container&#039;
//div&#x5B;@class=&#039;container&#039;]

# Chọn phần tử h2 trong phần tử div có class &#039;container&#039;
//div&#x5B;@class=&#039;container&#039;]/h2

# Chọn tất cả các phần tử li nằm trong phần tử div có class &#039;container&#039;
//div&#x5B;@class=&#039;container&#039;]//li

# Chọn phần tử div có class &#039;container&#039;
div.container

# Chọn phần tử h2 trong phần tử div có class &#039;container&#039;
div.container h2

# Chọn tất cả các phần tử li nằm trong phần tử div có class &#039;container&#039;
div.container li

# Chọn phần tử td thứ hai trong phần tử tr đầu tiên
//table/tbody/tr&#x5B;1]/td&#x5B;2]

# Chọn phần tử td thứ ba trong tất cả các phần tử tr trong tbody của bảng
//table/tbody/tr/td&#x5B;3]

# Chọn phần tử td thứ hai trong phần tử tr đầu tiên
table tbody tr:first-child td:nth-child(2)

# Chọn phần tử td thứ ba trong tất cả các phần tử tr trong tbody của bảng
table tbody tr td:nth-child(3)
</pre></div>
</body>
</html>
